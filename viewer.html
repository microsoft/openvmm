<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Petri test results</title>
    <style type="text/css">
        #logContainer table {
            width: 100%;
            border-collapse: collapse;
            font-family: monospace;
            font-size: 14px;
        }

        #logContainer th,
        #logContainer td {
            border: 1px solid #ddd;
            padding: 6px 10px;
            text-align: left;
        }

        #logContainer thead {
            background-color: #f0f0f0;
            font-weight: bold;
        }

        /* Zebra striping for rows */
        #logContainer tbody tr:nth-child(even) {
            background-color: #fafafa;
        }

        #logContainer tbody tr:nth-child(odd) {
            background-color: #ffffff;
        }

        /* Severity-based highlighting */
        #logContainer tr.severity-ERROR td {
            border-left: 4px solid #d00;
            color: #900;
        }

        #logContainer tr.severity-WARN td {
            border-left: 4px solid #d98e00;
            color: #a65f00;
        }

        #logContainer tr.severity-INFO td {
            border-left: 4px solid #007acc;
            color: #004e7a;
        }

        #logContainer tr.severity-DEBUG td {
            border-left: 4px solid #888;
            color: #555;
        }

        #logContainer td.timestamp {
            white-space: nowrap;
        }
    </style>
    <script>
        // Get the blob list, which is in XML via a GET request.
        function getTestList(path) {
            const url = "https://openvmmghtestresults.blob.core.windows.net/results?restype=container&comp=list&prefix=" + path;
            fetch(url)
                .then(response => response.text())
                .then(data => {
                    //console.log(data);
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(data, "text/xml");
                    const blobs = xmlDoc.getElementsByTagName("Blob");
                    let blobList = {};
                    for (let i = 0; i < blobs.length; i++) {
                        const name = blobs[i].getElementsByTagName("Name")[0].textContent;
                        const nameParts = name.split("/");
                        if (nameParts[nameParts.length - 1] !== "petri.jsonl") {
                            continue;
                        }
                        const testName = nameParts[nameParts.length - 2];
                        const testPass = nameParts[nameParts.length - 3];
                        if (!blobList[testPass]) {
                            blobList[testPass] = "";
                        }
                        blobList[testPass] += `<li><a href="?collection=${path}&pass=${testPass}&test=${testName}">${testName}</a></li>`;
                    }
                    let html = "<ul>";
                    for (const testPass in blobList) {
                        html += `<li>${testPass}<ul>${blobList[testPass]}</ul></li>`;
                    }
                    html += "</ul>";
                    document.getElementById("pass-list").innerHTML = html;
                })
                .catch(error => console.error('Error fetching blob list:', error));
        }

        function removeTimestamp(message, entryTimestamp) {
            const i = message.indexOf(" ");
            if (i === -1) {
                return message;
            }
            let ts = message.slice(0, i);
            if (ts.endsWith("s")) {
                const secs = parseFloat(ts.slice(0, -1));
                if (!isNaN(secs)) {
                    return message.slice(i + 1);
                }
            }

            if (ts.startsWith("[")) {
                ts = ts.slice(1, -1);
            }
            const parsedTs = new Date(ts);
            if (isNaN(parsedTs.getTime())) {
                return message;
            }
            parsedTs.setMilliseconds(0);
            const truncatedTs = new Date(entryTimestamp.getTime());
            truncatedTs.setMilliseconds(0);
            if (parsedTs.getTime() !== truncatedTs.getTime()) {
                return message;
            }
            return message.slice(i + 1);
        }

        function replaceSeverity(message, severity) {
            // If the message starts with a severity level, remove it and also return it.
            const severityLevels = ["ERROR", "WARN", "INFO", "DEBUG"];
            for (const level of severityLevels) {
                if (message.startsWith(level)) {
                    return {
                        message: message.slice(level.length).trim(),
                        severity: level
                    };
                }
            }
            // If no severity level is found, return the original message with INFO as default.
            return {
                message: message,
                severity: severity,
            };
        }

        function formatRelative(from, to) {
            const deltaMs = new Date(to) - new Date(from);
            const sec = (deltaMs % 1000000) / 1000;
            const min = Math.floor((deltaMs / 60000) % 60);
            const hr = Math.floor(deltaMs / 3600000);

            return `${hr > 0 ? hr + 'h ' : ''}${min}m ${sec}s`;
        }

        function ansiToHtml(str) {
            const ANSI_STYLE_MAP = {
                // Text styles
                '1': 'font-weight: bold',
                '3': 'font-style: italic',
                '4': 'text-decoration: underline',

                // Foreground colors
                '30': 'color: black', '31': 'color: red', '32': 'color: green',
                '33': 'color: yellow', '34': 'color: blue', '35': 'color: magenta',
                '36': 'color: cyan', '37': 'color: white',

                '90': 'color: gray', '91': 'color: lightcoral', '92': 'color: lightgreen',
                '93': 'color: gold', '94': 'color: lightskyblue', '95': 'color: plum',
                '96': 'color: lightcyan', '97': 'color: white',

                // Reset foreground
                '39': 'color: inherit'
            };

            const ESC = '\u001b';
            const ESC_REGEX = /\u001b\[([0-9;]*)m/g;

            let result = '';
            let lastIndex = 0;
            let currentStyles = [];

            const flush = (text) => {
                if (!text) return;
                if (currentStyles.length > 0) {
                    result += `<span style="${currentStyles.join('; ')}">${escapeHtml(text)}</span>`;
                } else {
                    result += escapeHtml(text);
                }
            };

            const escapeHtml = (text) => text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            for (const match of str.matchAll(ESC_REGEX)) {
                const [fullMatch, codeStr] = match;
                const index = match.index;

                // Flush plain text before this escape sequence
                flush(str.slice(lastIndex, index));

                // Update styles
                const codes = codeStr.split(';');
                for (const code of codes) {
                    if (code === '0') {
                        currentStyles = [];
                        continue;
                    }
                    const style = ANSI_STYLE_MAP[code];
                    if (style) {
                        // Replace style of the same type
                        const type = style.split(':')[0];
                        currentStyles = currentStyles.filter(s => !s.startsWith(type));
                        currentStyles.push(style);
                    }
                }

                lastIndex = index + fullMatch.length;
            }

            // Flush any trailing text
            flush(str.slice(lastIndex));
            return result;
        }

        function getTestResults(collection, pass, test) {
            const url = `https://openvmmghtestresults.blob.core.windows.net/results/${collection}/${pass}/${test}/petri.jsonl`;
            console.log(url);
            fetch(url)
                .then(response => response.text())
                .then(data => {
                    let lines = data.split("\n").filter(line => line.trim() !== "").map(line => JSON.parse(line));
                    lines.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    let html = `<table>
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                <th>Severity</th>
                                <th>Source</th>
                                <th>Message</th>
                            </tr>
                        </thead>
                        `;
                    let start;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];

                        const timestamp = line.timestamp;
                        let message = line.message || "";
                        let severity = line.severity || "INFO";
                        const source = line.source || "unknown";

                        if (!line.message) {
                            console.log(line);
                            continue;
                        }

                        if (!start) {
                            start = line.timestamp;
                        }
                        const relative = formatRelative(start, timestamp);

                        message = removeTimestamp(message.trim(), new Date(line.timestamp));

                        const r = replaceSeverity(message.trim(), severity);
                        message = r.message;
                        severity = r.severity;

                        const ansiMessage = ansiToHtml(message);
                        if (ansiMessage !== message) {
                            console.log("ANSI detected in message:", message);
                            console.log("Converted to HTML:", ansiMessage);
                            message = ansiMessage;
                        }

                        html += `<tr class="severity-${severity}">
                            <td class="timestamp" title="${timestamp}">${relative}</td>
                            <td>${severity}</td>
                            <td>${source}</td>
                            <td>${message}</td>
                        </tr>`;
                    }
                    html += "</table>";
                    document.getElementById("logContainer").innerHTML = html;
                })
                .catch(error => console.error('Error fetching test results:', error));
        }

        window.onload = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const collection = urlParams.get('collection');
            if (!collection) {
                document.getElementById("collection-name").innerText = "No collection specified";
                const raw = "\u001b[0;32m  OK  \u001b[0m Stopped \u001b[0;1;39msystemd-remount-fs.service\u001b[0m…";
                document.getElementById('logContainer').innerHTML = ansiToHtml(raw);
                return;
            }

            const test = urlParams.get('test');
            const pass = urlParams.get('pass');
            if (test) {
                document.getElementById("collection-name").innerText = test;
                document.getElementById("logContainer").innerText = "Loading...";
                getTestResults(collection, pass, test);
            } else {
                document.getElementById("collection-name").innerText = collection;
                document.getElementById("pass-list").innerText = "Loading...";
                getTestList(collection);
            }
        };
    </script>

</head>

<body>
    <h1 id="collection-name">Loading</h1>
    <div id="pass-list"></div>
    <div id="logContainer"></div>
</body>

</html>